package nl.tudelft.tbm.eeni.demo;

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.Iterator;
import java.util.List;

import nl.tudelft.tbm.eeni.demo.ont.category.ComponentTuple;
import nl.tudelft.tbm.eeni.demo.ont.category.FacilityOrMarketOrTechnology;
import nl.tudelft.tbm.eeni.demo.ont.category.GoodName;
import nl.tudelft.tbm.eeni.demo.ont.category.Market;
import nl.tudelft.tbm.eeni.demo.ont.category.OperationalConfiguration;
import nl.tudelft.tbm.eeni.demo.ont.category.PhysicalFlow;
import nl.tudelft.tbm.eeni.demo.ont.category.Technology;
import nl.tudelft.tbm.eeni.demo.ont.tools.Factory;
import nl.tudelft.tbm.eeni.demo.ont.tools.Vocabulary;
import nl.tudelft.tbm.eeni.owlstructure.utils.OntologyUtils;

import com.hp.hpl.jena.ontology.OntModel;
import com.hp.hpl.jena.ontology.OntProperty;
import com.hp.hpl.jena.query.Query;
import com.hp.hpl.jena.query.QueryExecution;
import com.hp.hpl.jena.query.QueryExecutionFactory;
import com.hp.hpl.jena.query.QueryFactory;
import com.hp.hpl.jena.query.ResultSet;
import com.hp.hpl.jena.query.Syntax;
import com.hp.hpl.jena.shared.Lock;


/**
 * 
 * This demo application shows how to work with classes generated by owl2java.
 * Therefore you need to generate the auto-generated code first by running the ClassGenerator program.
 * 
 */
public class Application {
	final static double PRODUCTION_MARKUP = 1.1d;
	final static double IMPORT_MARKUP = 1.5d;
	final static double EXPORT_MARKUP = .667d;
	final static double PRICE_CONVOLUTION = .25d;

	final static int TICKS = 50;

	public static void main(String[] args) {
		// Load the ontology
		OntModel ontModel = OntologyUtils.loadOntology("file:resources/demo/industries-application.owl");

		// Initialiaze the autogenerated ontology wrappers
		Factory.setDefaultModel(ontModel);
		Factory.registerCustomClasses();

		for (ComponentTuple tuple: ComponentTuple.list()) {
			if (!tuple.existsRelativeAmount()) {
				tuple.setRelativeAmount(10000d);
			}
		}
		// Delete all technologies without (or with broken) operational configurations
		for(Technology technology: Technology.list()) {
			if (technology.getCurrentOperationalConfiguration() == null) {
				technology.remove();
			}
		}

		// Remove all existing PhysicalFlows
		for(PhysicalFlow physicalFlow: PhysicalFlow.list()) {
			physicalFlow.remove();
		}

		// Initialze all local prices to a random value
		for (GoodName good: GoodName.list()) {
			good.setLocalPrice(1d);
		}

		// Initialize price setting mechanism by copying local unit prices to operationalOutput unit prices
		for(Technology technology: Technology.list()) {
			OperationalConfiguration config = technology.getCurrentOperationalConfiguration();
			if (config.existsOperationalOutput()) {
				ComponentTuple output = config.getOperationalOutput();
				output.setUnitPrice(output.getGoodName().as(GoodName.class).getLocalPrice());
			}
		}

		// Create a world market instance
		Market worldMarket = Market.create(Vocabulary.NSWIKI + "world_market");
		worldMarket.setLabel("WorldMarket");

		/*
		 * Main event loop
		 */
		for (int tick = 1; tick <= TICKS; tick++) {
			// Calculate output prices per of the output based on current market prices
			for(Technology technology: Technology.list()) {
				OperationalConfiguration config = technology.getCurrentOperationalConfiguration();
				if (config.existsOperationalOutput()) {
					// Are there any inputs to calculate with?
					if (config.countOperationalInputs() > 0) {
						double inputCost = 0;
						for (ComponentTuple input: config.listOperationalInputs()) {
							inputCost += input.getRelativeAmount() * input.getGoodName().as(GoodName.class).getLocalPrice();
						}
						ComponentTuple output = config.getOperationalOutput();
						double competitivePrice = inputCost / output.getRelativeAmount() * PRODUCTION_MARKUP;
						output.setUnitPrice(PRICE_CONVOLUTION * competitivePrice + (1 - PRICE_CONVOLUTION) * output.getGoodName().as(GoodName.class).getLocalPrice());
					}
				}
			}

			// Clear all existing PhysicalFlows and reset connectedAmount properties of inputs/outputs in preparation for flow renegotiation
			for(PhysicalFlow physicalFlow: PhysicalFlow.list()) {
				physicalFlow.remove();
			}
			for(Technology technology: Technology.list()) {
				OperationalConfiguration config = technology.getCurrentOperationalConfiguration();
				for (ComponentTuple input: config.listOperationalInputs()) {
					input.setConnectedAmount(0d);
				}
				config.getOperationalOutput().setConnectedAmount(0d);
			}

			// Renegotiate all flows
			for (GoodName good: GoodName.list()) {
				// Find unconnected input and output pins for this good
				List<ComponentTuple> availableOutputs = findUnconnectedPins(good, Vocabulary.operationalOutput);
				List<ComponentTuple> unconnectedInputs = findUnconnectedPins(good, Vocabulary.operationalInputs);

				// Outputs are sorted by unit price so the best deals are made first
				Collections.sort(availableOutputs, new Comparator<ComponentTuple>() {
					@Override
					public int compare(ComponentTuple a, ComponentTuple b) {
						return Double.compare(a.getUnitPrice(), b.getUnitPrice());
					}
				});

				// Inputs are shuffled so the order in which deals are picked are randomized, so each tick a different technology will get to pick the best deals
				Collections.shuffle(unconnectedInputs);

				// Register the size of local trade and the amount of money involved, so we can calculate the average local price
				double localTradeAmount = 0;
				double localTradeMoney = 0;

				while (unconnectedInputs.size() > 0 && availableOutputs.size() > 0) {
					ComponentTuple input = unconnectedInputs.get(0);
					ComponentTuple bestOutput = availableOutputs.get(0);

					// Connect bestOutput to input
					double amount = Math.max(input.getRelativeAmount() - input.getConnectedAmount(), bestOutput.getRelativeAmount() - bestOutput.getConnectedAmount());
					double unitPrice = bestOutput.getUnitPrice();

					// Create a flow
					PhysicalFlow flow = PhysicalFlow.create();
					flow.setUnitPrice(amount);

					flow.setGoodName(good);
					flow.setRelativeAmount(amount);
					flow.setUnitPrice(unitPrice);
					flow.setFrom(findInputOutputTechnology(bestOutput));
					flow.setTo(findInputOutputTechnology(input));

					// Update connectedAmount values
					input.setConnectedAmount(input.getConnectedAmount() + amount);
					bestOutput.setConnectedAmount(bestOutput.getConnectedAmount() + amount);

					// Remove fully connected pins from the input/output list
					if (input.getConnectedAmount() >= input.getRelativeAmount()) {
						unconnectedInputs.remove(0);
					}
					if (bestOutput.getConnectedAmount() >= bestOutput.getRelativeAmount()) {
						availableOutputs.remove(0);
					}

					// Count amount and money
					localTradeAmount += amount;
					localTradeMoney += amount * unitPrice;
				}

				// Update local price if any local trade has taken place
				if (localTradeAmount > 0) {
					good.setLocalPrice(localTradeMoney / localTradeAmount);
				}

				// Any unsatisfied inputs trade with the world market
				double importPrice = good.getLocalPrice() * IMPORT_MARKUP;
				Iterator<ComponentTuple> inputIterator = unconnectedInputs.iterator();
				while (inputIterator.hasNext()) {
					ComponentTuple input = inputIterator.next();
					double amount = input.getRelativeAmount() - input.getConnectedAmount();

					// Create a flow
					PhysicalFlow flow = PhysicalFlow.create();
					flow.setGoodName(good);
					flow.setRelativeAmount(amount);
					flow.setUnitPrice(importPrice);
					flow.setFrom(worldMarket.as(FacilityOrMarketOrTechnology.class));
					flow.setTo(findInputOutputTechnology(input));

					// Update connected amount
					input.setConnectedAmount(input.getRelativeAmount());
				}

				// Any unsatisfied outputs trade with the world market
				double exportPrice = good.getLocalPrice() * EXPORT_MARKUP;
				Iterator<ComponentTuple> outputIterator = availableOutputs.iterator();
				while (outputIterator.hasNext()) {
					ComponentTuple output = outputIterator.next();
					double amount = output.getRelativeAmount() - output.getConnectedAmount();

					// Create a flow
					PhysicalFlow flow = PhysicalFlow.create();
					flow.setGoodName(good);
					flow.setRelativeAmount(amount);
					flow.setUnitPrice(exportPrice);
					flow.setFrom(findInputOutputTechnology(output));
					flow.setTo(worldMarket);

					// Update connected amount
					output.setConnectedAmount(output.getRelativeAmount());
				}
			}

			/*
			 * Dump information
			 */
			System.out.println("---------- Tick " + tick + " ----------");

			List<GoodName> goods = GoodName.list();
			Collections.sort(goods, new Comparator<GoodName>() {
				@Override
				public int compare(GoodName a, GoodName b) {
					return a.getLabel().compareToIgnoreCase(b.getLabel());
				}
			});
	        DecimalFormat formatter = new DecimalFormat("#0.00");
			for (GoodName good: goods) {
				double localPrice = good.getLocalPrice();
				if (localPrice != 1.0d) {
					System.out.println(good.getLabel() + ": ¤ " + formatter.format(good.getLocalPrice()) + " per Mton");
				}
			}
		}
	}

	/**
	 * Look for inputs or outputs of OpetationalConfigurations that are not fully balanced 
	 */
	private static List<ComponentTuple> findUnconnectedPins(GoodName good, OntProperty pin) {
		return query(
			  "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>"
			+ "SELECT ?technology ?config ?pin "
			+ "WHERE { "
			+ "  ?technology rdf:type <" + Vocabulary.Technology + "> . "
			+ "  ?technology <" + Vocabulary.currentOperationalConfiguration + "> ?config . "
			+ "  ?config <" + pin + "> ?pin . "
			+ "  ?pin <" + Vocabulary.relativeAmount + "> ?totalAmount . "
			+ "  ?pin <" + Vocabulary.connectedAmount + "> ?connectedAmount . "
			+ "  ?pin rdf:type <" + Vocabulary.ComponentTuple + "> . "
			+ "  ?pin <" + Vocabulary.goodName + "> <" + good.getURI() + "> . "
			+ "  ?pin <" + Vocabulary.relativeAmount + "> ?relamount . "
			+ "  FILTER ( ?totalAmount > ?connectedAmount ) . "
			+ "} ",
			new QueryResultSink<List<ComponentTuple>>() {
				@Override
				public List<ComponentTuple> consume(ResultSet results) {
					List<ComponentTuple> outputs = new ArrayList<ComponentTuple>();
					while (results.hasNext()) {
						outputs.add(results.nextSolution().getResource("pin").as(ComponentTuple.class));
					}
					return outputs;
				}
			});
	}

	/*
	 * Find the technology to which an OperationalInput or OperationalOutput belongs
	 */
	private static Technology findInputOutputTechnology(ComponentTuple io) {
		return query(
			  "PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>"
			+ "SELECT ?technology "
			+ "WHERE { "
			+ "  ?technology rdf:type <" + Vocabulary.Technology + "> . "
			+ "  ?technology <" + Vocabulary.currentOperationalConfiguration + "> ?config . "
			+ "  ?config (<" + Vocabulary.operationalInputs + "> | <" + Vocabulary.operationalOutput + ">) <" + io.getURI() + "> . "
			+ "} "
			+ "LIMIT 1",
			new QueryResultSink<Technology>() {
				@Override
				public Technology consume(ResultSet results) {
					if (results.hasNext()) {
						return results.nextSolution().getResource("technology").as(Technology.class);
					}
					return null;
				}
			});
	}

	private abstract static interface QueryResultSink<T> {
		public abstract T consume(ResultSet results);
	}

	private static <T> T query(String queryString, QueryResultSink<T> consumer) {
		OntModel ontModel = Factory.getDefaultModel();
		T returnValue = null;

		ontModel.enterCriticalSection(Lock.READ);
		try {
			Query query = QueryFactory.create(queryString, Syntax.syntaxARQ);
			QueryExecution qexec = QueryExecutionFactory.create(query, ontModel);

			ResultSet results = qexec.execSelect();
			returnValue = consumer.consume(results);

			while (results.hasNext());

			qexec.close();
		} finally {
			ontModel.leaveCriticalSection();
		}

		return returnValue;
	}
}
